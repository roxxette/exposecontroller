package exposestrategy

import (
	"reflect"

	"github.com/pkg/errors"

	"k8s.io/kubernetes/pkg/api"
	"k8s.io/kubernetes/pkg/api/v1"
	"k8s.io/kubernetes/pkg/runtime"

	oclient "github.com/openshift/origin/pkg/client"
	rapi "github.com/openshift/origin/pkg/route/api"
	rapiv1 "github.com/openshift/origin/pkg/route/api/v1"
	apierrors "k8s.io/kubernetes/pkg/api/errors"
	client "k8s.io/kubernetes/pkg/client/unversioned"
)

type RouteStrategy struct {
	client  *client.Client
	oclient *oclient.Client
	encoder runtime.Encoder

	domain  string
	host    string
	usePath bool
	http    bool
}

var _ ExposeStrategy = &RouteStrategy{}

func NewRouteStrategy(client *client.Client, oclient *oclient.Client, encoder runtime.Encoder, domain, routeHost string, routeUsePath, http bool) (*RouteStrategy, error) {
	t, err := typeOfMaster(client)
	if err != nil {
		return nil, errors.Wrap(err, "could not create new route strategy")
	}
	if t == kubernetes {
		return nil, errors.New("route strategy is not supported on Kubernetes, please use Ingress strategy")
	}

	/*

		we don't need the domain for route mode!

		if len(domain) == 0 {
			domain, err = getAutoDefaultDomain(client)
			if err != nil {
				return nil, errors.Wrap(err, "failed to get a domain")
			}
			glog.Infof("Using domain: %s", domain)
		}
	*/

	rapi.AddToScheme(api.Scheme)
	rapiv1.AddToScheme(api.Scheme)

	return &RouteStrategy{
		client:  client,
		oclient: oclient,
		encoder: encoder,
		domain:  domain,
		host:    routeHost,
		usePath: routeUsePath,
		http:    http}, nil
}

func (s *RouteStrategy) Add(svc *api.Service) error {
	// we don't need to fill in the host name as openshift will do that part for us!
	//hostName := fmt.Sprintf("%s.%s.%s", svc.Name, svc.Namespace, s.domain)

	createRoute := false
	route, err := s.oclient.Routes(svc.Namespace).Get(svc.Name)
	if err != nil {
		if apierrors.IsNotFound(err) {
			createRoute = true
			route = &rapi.Route{
				ObjectMeta: api.ObjectMeta{
					Namespace: svc.Namespace,
					Name:      svc.Name,
				},
			}
		} else {
			return errors.Wrapf(err, "could not check for existing route %s/%s", svc.Namespace, svc.Name)
		}
	}

	if route.Labels == nil {
		route.Labels = map[string]string{}
	}

	path := ""
	if s.usePath {
		path := svc.Annotations["fabric8.io/ingress.path"]
		if len(path) == 0 {
			path = "/" + svc.Name
		}
	}
	var hostName string
	protocol := "http"
	if createRoute {
		route.Labels["provider"] = "fabric8"
		route.Spec = rapi.RouteSpec{
			To:   rapi.RouteTargetReference{Name: svc.Name},
			Host: s.host,
			Path: path,
		}

		if !s.http {
			route.Spec.TLS = new(rapi.TLSConfig)
			route.Spec.TLS.Termination = rapi.TLSTerminationEdge
			route.Spec.TLS.InsecureEdgeTerminationPolicy = rapi.InsecureEdgeTerminationPolicyRedirect
		}

		route.Labels["generator"] = "exposecontroller"
		updated, err := s.oclient.Routes(route.Namespace).Create(route)
		if err != nil {
			return errors.Wrapf(err, "failed to create route %s/%s", route.Namespace, route.Name)
		}
		hostName, protocol = hostNameAndProtocolFromRoute(svc, updated)
	} else {
		generator := route.Labels["generator"]
		if s.usePath && (route.Spec.Path != path || route.Spec.Host != s.host) {
			// we have to delete and recreate the route
			err = s.oclient.Routes(route.Namespace).Delete(route.Name)
			if err != nil {
				return errors.Wrapf(err, "failed to delete old %s/%s", route.Namespace, route.Name)
			}
			route.Spec.Host = s.host
			route.Spec.Path = path
			route.ResourceVersion = ""
			if !s.http {
				if route.Spec.TLS == nil {
					route.Spec.TLS = new(rapi.TLSConfig)
				}
				route.Spec.TLS.Termination = "edge"
				route.Spec.TLS.InsecureEdgeTerminationPolicy = "Redirect"
			}
			//route.Status = rapiv1.RouteStatus{}
			route.Labels["generator"] = "exposecontroller"
			updated, err := s.oclient.Routes(route.Namespace).Create(route)
			if err != nil {
				return errors.Wrapf(err, "failed to create route %s/%s", route.Namespace, route.Name)
			}
			hostName, protocol = hostNameAndProtocolFromRoute(svc, updated)
		} else if generator == "exposecontroller" {
			// lets only update the route if the route that exists was created by exposecontroller
			updated, err := s.oclient.Routes(route.Namespace).Update(route)
			if err != nil {
				return errors.Wrapf(err, "failed to update route %s/%s", route.Namespace, route.Name)
			}
			hostName, protocol = hostNameAndProtocolFromRoute(svc, updated)
		} else {
			//glog.Infof("Not updating route %s as it was not generated by exposecontroller", svc.Name)
			hostName, protocol = hostNameAndProtocolFromRoute(svc, route)
		}
	}

	cloned, err := api.Scheme.DeepCopy(svc)
	if err != nil {
		return errors.Wrap(err, "failed to clone service")
	}
	clone, ok := cloned.(*api.Service)
	if !ok {
		return errors.Errorf("cloned to wrong type: %s", reflect.TypeOf(cloned))
	}

	if len(hostName) == 0 {
		return errors.Wrap(err, "cannot add service annotation as OpenShift has not defaulted the hostName on the Route.Spec")
	}
	clone, err = addServiceAnnotationWithProtocol(clone, hostName, protocol)
	if err != nil {
		return errors.Wrap(err, "failed to add service annotation")
	}
	patch, err := createPatch(svc, clone, s.encoder, v1.Service{})
	if err != nil {
		return errors.Wrap(err, "failed to create patch")
	}
	if patch != nil {
		err = s.client.Patch(api.StrategicMergePatchType).
			Resource("services").
			Namespace(svc.Namespace).
			Name(svc.Name).
			Body(patch).Do().Error()
		if err != nil {
			return errors.Wrap(err, "failed to send patch")
		}
	}
	return nil
}

func hostNameAndProtocolFromRoute(svc *api.Service, route *rapi.Route) (string, string) {
	protocol := "http"
	spec := route.Spec
	hostName := spec.Host + spec.Path
	if spec.TLS != nil {
		protocol = "https"
	} else {
		protocol = findHttpProtocol(svc, hostName)
	}
	return hostName, protocol
}

func (s *RouteStrategy) Remove(svc *api.Service) error {
	err := s.oclient.Routes(svc.Namespace).Delete(svc.Name)
	if err != nil && !apierrors.IsNotFound(err) {
		return errors.Wrap(err, "failed to delete route")
	}

	cloned, err := api.Scheme.DeepCopy(svc)
	if err != nil {
		return errors.Wrap(err, "failed to clone service")
	}
	clone, ok := cloned.(*api.Service)
	if !ok {
		return errors.Errorf("cloned to wrong type: %s", reflect.TypeOf(cloned))
	}

	clone = removeServiceAnnotation(clone)

	patch, err := createPatch(svc, clone, s.encoder, v1.Service{})
	if err != nil {
		return errors.Wrap(err, "failed to create patch")
	}
	if patch != nil {
		err = s.client.Patch(api.StrategicMergePatchType).
			Resource("services").
			Namespace(clone.Namespace).
			Name(clone.Name).
			Body(patch).Do().Error()
		if err != nil {
			return errors.Wrap(err, "failed to send patch")
		}
	}

	return nil
}
